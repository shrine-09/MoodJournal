@page "/analytics"
@using System.Globalization
@using MoodJournal.Models
@using MoodJournal.Services
@inject JournalRepository Repo
@inject IJSRuntime JS

<div class="analytics-page">
    <div class="analytics-header">
        <h1 class="h1">Analytics</h1>
        <div class="subtle">Filter by date range and view insights.</div>
    </div>

    <div class="card analytics-toolbar">
        <div class="analytics-toolbar-row">
            <div class="analytics-range">
                <div class="field">
                    <label class="label">From</label>
                    <input class="mj-input mj-date" type="date" value="@FromDraft" @onchange="OnFromChanged" />
                </div>

                <div class="field">
                    <label class="label">To</label>
                    <input class="mj-input mj-date" type="date" value="@ToDraft" @onchange="OnToChanged" />
                </div>
            </div>

            <div class="analytics-actions">
                <button class="btn" type="button" @onclick="Apply">Apply</button>
                <button class="btn btn-ghost" type="button" @onclick="ResetToLast30Days">Last 30 days</button>
            </div>
        </div>


        <div class="subtle analytics-meta">
            Showing <b>@FilteredCount</b> entries from <b>@FromAppliedLabel</b> to <b>@ToAppliedLabel</b>
        </div>
    </div>

    @if (FilteredCount == 0)
    {
        <div class="card empty">No entries found in this date range.</div>
    }
    else
    {
        <div class="analytics-grid">
            <div class="card chart-card">
                <div class="chart-title">Mood Distribution (Positive / Neutral / Negative)</div>
                <div class="chart-wrap">
                    <canvas id="moodDistChart"></canvas>
                </div>
                <div class="chart-foot subtle">@MoodDistText</div>
            </div>

            <div class="card chart-card">
                <div class="chart-title">Frequent Moods (Top)</div>
                <div class="chart-wrap">
                    <canvas id="frequentMoodsChart"></canvas>
                </div>
            </div>

            <div class="card chart-card">
                <div class="chart-title">Most Used Tags (Top)</div>
                <div class="chart-wrap">
                    <canvas id="mostUsedTagsChart"></canvas>
                </div>
            </div>

            <div class="card chart-card">
                <div class="chart-title">Tag Breakdown (% of entries)</div>
                <div class="chart-wrap">
                    <canvas id="tagBreakdownChart"></canvas>
                </div>
            </div>

            <div class="card chart-card chart-span-2">
                <div class="chart-title">Word Count Trends</div>
                <div class="chart-wrap tall">
                    <canvas id="wordCountTrendChart"></canvas>
                </div>
                <div class="chart-foot subtle">Average words per entry: <b>@AvgWords</b></div>
            </div>
        </div>
    }
</div>

@code {
    private List<JournalEntry> _all = new();
    private List<JournalEntry> _filtered = new();
    
    private string FromDraft = "";
    private string ToDraft = "";
    
    private DateTime FromApplied;
    private DateTime ToApplied;

    private bool _needsChartUpdate = false;
    
    private string MoodDistText = "";
    private int AvgWords = 0;
    
    private static readonly HashSet<string> Positive = new(StringComparer.OrdinalIgnoreCase)
    { "Happy","Excited","Relaxed","Grateful","Confident" };

    private static readonly HashSet<string> Neutral = new(StringComparer.OrdinalIgnoreCase)
    { "Calm","Thoughtful","Curious","Nostalgic","Bored" };

    private static readonly HashSet<string> Negative = new(StringComparer.OrdinalIgnoreCase)
    { "Sad","Angry","Stressed","Lonely","Anxious" };

    private int FilteredCount => _filtered.Count;

    private string FromAppliedLabel => FromApplied.ToString("MMM d, yyyy", CultureInfo.InvariantCulture);
    private string ToAppliedLabel => ToApplied.ToString("MMM d, yyyy", CultureInfo.InvariantCulture);

    protected override async Task OnInitializedAsync()
    {
        _all = await Repo.GetAllAsync();
        ResetToLast30Days();
    }

    private void ResetToLast30Days()
    {
        var today = DateTime.Today;
        FromApplied = today.AddDays(-29);
        ToApplied = today;

        FromDraft = FromApplied.ToString("yyyy-MM-dd");
        ToDraft = ToApplied.ToString("yyyy-MM-dd");

        ApplyInternal();
    }

    private void OnFromChanged(ChangeEventArgs e) => FromDraft = e.Value?.ToString() ?? "";
    private void OnToChanged(ChangeEventArgs e) => ToDraft = e.Value?.ToString() ?? "";

    private void Apply()
    {
        var from = TryParseDate(FromDraft) ?? DateTime.Today.AddDays(-29);
        var to = TryParseDate(ToDraft) ?? DateTime.Today;

        if (to < from)
        {
            (from, to) = (to, from);
        }

        FromApplied = from.Date;
        ToApplied = to.Date;

        ApplyInternal();
    }

    private void ApplyInternal()
    {
        _filtered = _all
            .Where(e =>
            {
                var d = ParseEntryDate(e.EntryDate);
                return d >= FromApplied && d <= ToApplied;
            })
            .OrderBy(e => e.EntryDate)
            .ToList();

        ComputeMetricsForCharts();
        _needsChartUpdate = true;
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!_needsChartUpdate) return;
        _needsChartUpdate = false;

        if (_filtered.Count == 0)
        {
            //optional: destroy charts when empty
            await JS.InvokeVoidAsync("mjChartsDestroy", "moodDistChart");
            await JS.InvokeVoidAsync("mjChartsDestroy", "frequentMoodsChart");
            await JS.InvokeVoidAsync("mjChartsDestroy", "mostUsedTagsChart");
            await JS.InvokeVoidAsync("mjChartsDestroy", "tagBreakdownChart");
            await JS.InvokeVoidAsync("mjChartsDestroy", "wordCountTrendChart");
            return;
        }

        //Mood Distribution doughnut
        await JS.InvokeVoidAsync("mjChartsInitOrUpdate",
            "moodDistChart",
            "doughnut",
            _moodDistLabels,
            _moodDistData,
            "Mood % (range)",
            "{}");

        //Frequent moods bar
        await JS.InvokeVoidAsync("mjChartsInitOrUpdate",
            "frequentMoodsChart",
            "bar",
            _freqMoodLabels,
            _freqMoodData,
            "Count",
            "{\"plugins\":{\"legend\":{\"display\":false}}}");

        //Most used tags bar
        await JS.InvokeVoidAsync("mjChartsInitOrUpdate",
            "mostUsedTagsChart",
            "bar",
            _tagTopLabels,
            _tagTopData,
            "Uses",
            "{\"plugins\":{\"legend\":{\"display\":false}}}");

        //Tag breakdown ibut in % bar
        await JS.InvokeVoidAsync("mjChartsInitOrUpdate",
            "tagBreakdownChart",
            "bar",
            _tagBreakLabels,
            _tagBreakData,
            "% of entries",
            "{\"plugins\":{\"legend\":{\"display\":false}},\"scales\":{\"y\":{\"beginAtZero\":true,\"max\":100}}}");

        //Word count trends line
        await JS.InvokeVoidAsync("mjChartsInitOrUpdate",
            "wordCountTrendChart",
            "line",
            _wcLabels,
            _wcData,
            "Words",
            "{\"plugins\":{\"legend\":{\"display\":false}}}");
    }
    
    private string[] _moodDistLabels = Array.Empty<string>();
    private double[] _moodDistData = Array.Empty<double>();

    private string[] _freqMoodLabels = Array.Empty<string>();
    private double[] _freqMoodData = Array.Empty<double>();

    private string[] _tagTopLabels = Array.Empty<string>();
    private double[] _tagTopData = Array.Empty<double>();

    private string[] _tagBreakLabels = Array.Empty<string>();
    private double[] _tagBreakData = Array.Empty<double>();

    private string[] _wcLabels = Array.Empty<string>();
    private double[] _wcData = Array.Empty<double>();

    private void ComputeMetricsForCharts()
    {
        //mood distribution as %
        int pos = 0, neu = 0, neg = 0;
        foreach (var e in _filtered)
        {
            var m = e.PrimaryMood ?? "";
            if (Positive.Contains(m)) pos++;
            else if (Neutral.Contains(m)) neu++;
            else if (Negative.Contains(m)) neg++;
            else neu++;
        }

        var total = Math.Max(1, _filtered.Count);
        var posPct = pos * 100.0 / total;
        var neuPct = neu * 100.0 / total;
        var negPct = neg * 100.0 / total;

        _moodDistLabels = new[] { "Positive", "Neutral", "Negative" };
        _moodDistData = new[] { posPct, neuPct, negPct };
        MoodDistText = $"Positive {posPct:0.#}% • Neutral {neuPct:0.#}% • Negative {negPct:0.#}%";

        //frequent moods (top 8)
        var moodCounts = _filtered
            .GroupBy(e => (e.PrimaryMood ?? "Unknown").Trim())
            .Select(g => new { Mood = g.Key, Count = g.Count() })
            .OrderByDescending(x => x.Count)
            .ThenBy(x => x.Mood)
            .Take(8)
            .ToList();

        _freqMoodLabels = moodCounts.Select(x => x.Mood).ToArray();
        _freqMoodData = moodCounts.Select(x => (double)x.Count).ToArray();
        
        var tagUseCounts = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        var tagEntryCounts = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);

        foreach (var e in _filtered)
        {
            var tags = SplitTags(e.TagsCsv).ToList();
            if (tags.Count == 0) continue;
            
            foreach (var t in tags)
            {
                if (!tagUseCounts.ContainsKey(t)) tagUseCounts[t] = 0;
                tagUseCounts[t]++;
            }

            //entries containing tag (distinct)
            foreach (var t in tags.Distinct(StringComparer.OrdinalIgnoreCase))
            {
                if (!tagEntryCounts.ContainsKey(t)) tagEntryCounts[t] = 0;
                tagEntryCounts[t]++;
            }
        }

        //Most used tags (top 10 by occurrences)
        var topTags = tagUseCounts
            .OrderByDescending(kv => kv.Value)
            .ThenBy(kv => kv.Key)
            .Take(10)
            .ToList();

        _tagTopLabels = topTags.Select(x => x.Key).ToArray();
        _tagTopData = topTags.Select(x => (double)x.Value).ToArray();

        //Tag breakdown by % of entries (top 8 by entry count)
        var topBreak = tagEntryCounts
            .OrderByDescending(kv => kv.Value)
            .ThenBy(kv => kv.Key)
            .Take(8)
            .ToList();

        _tagBreakLabels = topBreak.Select(x => x.Key).ToArray();
        _tagBreakData = topBreak.Select(x => x.Value * 100.0 / total).ToArray();

        //Word count trends
        var wc = _filtered
            .OrderBy(e => e.EntryDate)
            .Select(e => new
            {
                Date = ParseEntryDate(e.EntryDate),
                Words = Math.Max(0, e.WordCount)
            })
            .ToList();

        _wcLabels = wc.Select(x => x.Date.ToString("MMM d", CultureInfo.InvariantCulture)).ToArray();
        _wcData = wc.Select(x => (double)x.Words).ToArray();

        AvgWords = (int)Math.Round(wc.Select(x => x.Words).DefaultIfEmpty(0).Average());
    }

    private static DateTime ParseEntryDate(string entryDate) =>
        DateTime.ParseExact(entryDate, "yyyy-MM-dd", CultureInfo.InvariantCulture).Date;

    private static DateTime? TryParseDate(string s)
    {
        if (string.IsNullOrWhiteSpace(s)) return null;
        if (DateTime.TryParseExact(s, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out var dt))
            return dt.Date;
        return null;
    }

    private static IEnumerable<string> SplitTags(string? csv)
    {
        if (string.IsNullOrWhiteSpace(csv)) return Enumerable.Empty<string>();
        return csv.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
    }

}
