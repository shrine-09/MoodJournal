@page "/analytics"
@using System.Globalization
@using MoodJournal.Models
@using MoodJournal.Services
@inject JournalRepository Repo

<div class="analytics-page">
    <div class="analytics-header">
        <h1 class="h1">Analytics</h1>
        <div class="subtle">Filter by date range and view insights.</div>
    </div>

    <div class="card analytics-toolbar">
        <div class="toolbar-row">
            <div class="date-row">
                <div class="field">
                    <label class="label">From</label>
                    <input class="mj-input mj-date-input" type="date" value="@FromDraft" @onchange="OnFromChanged" />
                </div>

                <div class="field">
                    <label class="label">To</label>
                    <input class="mj-input mj-date-input" type="date" value="@ToDraft" @onchange="OnToChanged" />
                </div>
            </div>

            <div class="toolbar-actions">
                <button class="btn" type="button" @onclick="Apply">Apply</button>
                <button class="btn btn-ghost" type="button" @onclick="ResetToLast30Days">Last 30 days</button>
            </div>
        </div>

        <div class="subtle analytics-meta">
            Showing <b>@FilteredCount</b> entries from <b>@FromAppliedLabel</b> to <b>@ToAppliedLabel</b>
        </div>
    </div>

    @if (FilteredCount == 0)
    {
        <div class="card empty">No entries found in this date range.</div>
    }
    else
    {
        <div class="analytics-grid">

            <!-- Mood Distribution -->
            <div class="card chart-card">
                <div class="chart-title">Mood Distribution (Positive / Neutral / Negative)</div>

                <div class="pie-row">
                    <div class="pie" style="@MoodPieStyle">
                        <div class="pie-hole"></div>
                    </div>

                    <div class="pie-legend">
                        <div class="legend-item">
                            <span class="dot dot-pos"></span>
                            <span>Positive</span>
                            <b>@PosPct.ToString("0.#")%</b>
                        </div>
                        <div class="legend-item">
                            <span class="dot dot-neu"></span>
                            <span>Neutral</span>
                            <b>@NeuPct.ToString("0.#")%</b>
                        </div>
                        <div class="legend-item">
                            <span class="dot dot-neg"></span>
                            <span>Negative</span>
                            <b>@NegPct.ToString("0.#")%</b>
                        </div>

                        <div class="subtle pie-foot">@MoodDistText</div>
                    </div>
                </div>
            </div>

            <!-- Frequent moods -->
            <div class="card chart-card">
                <div class="chart-title">
                    Frequent Moods (Top)
                    <div class="mini-toggle">
                        <button type="button" class="pill-btn @(ShowMoodCloud ? "" : "is-active")" @onclick="() => ShowMoodCloud = false">Bars</button>
                        <button type="button" class="pill-btn @(ShowMoodCloud ? "is-active" : "")" @onclick="() => ShowMoodCloud = true">Word cloud</button>
                    </div>
                </div>

                @if (!ShowMoodCloud)
                {
                    <div class="bars">
                        @foreach (var item in TopMoods)
                        {
                            <div class="bar-row">
                                <div class="bar-label">@item.Name</div>
                                <div class="bar-track">
                                    <div class="bar-fill" style="width:@item.WidthPct.ToString("0.#", CultureInfo.InvariantCulture)%"></div>
                                </div>
                                <div class="bar-value">@item.Count</div>
                            </div>
                        }
                    </div>
                }
                else
                {
                    <div class="cloud">
                        @foreach (var item in TopMoods)
                        {
                            <span class="cloud-word" style="font-size:@item.CloudSizePx.ToString("0.#", CultureInfo.InvariantCulture)px">
                                @item.Name
                            </span>
                        }
                    </div>
                }
            </div>

            <!-- Most used tags -->
            <div class="card chart-card">
                <div class="chart-title">Most Used Tags (Top)</div>

                <div class="bars">
                    @foreach (var item in TopTagsByUse)
                    {
                        <div class="bar-row">
                            <div class="bar-label">@item.Name</div>
                            <div class="bar-track">
                                <div class="bar-fill" style="width:@item.WidthPct.ToString("0.#", CultureInfo.InvariantCulture)%"></div>
                            </div>
                            <div class="bar-value">@item.Count</div>
                        </div>
                    }
                </div>
            </div>

            <!-- Tag breakdown -->
            <div class="card chart-card">
                <div class="chart-title">Tag Breakdown (% of entries)</div>

                <div class="bars">
                    @foreach (var item in TagBreakdown)
                    {
                        <div class="bar-row">
                            <div class="bar-label">@item.Name</div>
                            <div class="bar-track">
                                <div class="bar-fill" style="width:@item.WidthPct.ToString("0.#", CultureInfo.InvariantCulture)%"></div>
                            </div>
                            <div class="bar-value">@item.Percent.ToString("0.#")%</div>
                        </div>
                    }
                </div>

                <div class="subtle chart-foot">Based on entries that include the tag (each tag counted once per entry).</div>
            </div>

            <!-- Word Count Trends -->
            <div class="card chart-card chart-span-2">
                <div class="chart-title">Word Count Trends (Monthly Average)</div>

                <div class="trend-wrap">
                    <svg class="trend-svg" viewBox="0 0 700 220" preserveAspectRatio="none" aria-label="Word count trend">
                        <!-- axes -->
                        <line x1="40" y1="20" x2="40" y2="190" class="axis" />
                        <line x1="40" y1="190" x2="680" y2="190" class="axis" />

                        <!-- line -->
                        <polyline points="@TrendPoints" class="trend-line" />
                    </svg>

                    <div class="trend-legend">
                        <div class="subtle">Average words per entry (range): <b>@AvgWords</b></div>
                        <div class="subtle">Months: <b>@MonthlySeries.Count</b></div>
                    </div>

                    <div class="trend-labels">
                        @foreach (var m in MonthlySeries)
                        {
                            <span class="trend-label">@m.Label</span>
                        }
                    </div>
                </div>
            </div>

        </div>
    }
</div>

@code {
    private List<JournalEntry> _all = new();
    private List<JournalEntry> _filtered = new();

    private string FromDraft = "";
    private string ToDraft = "";

    private DateTime FromApplied;
    private DateTime ToApplied;

    private bool ShowMoodCloud = false;

    // Mood sets
    private static readonly HashSet<string> Positive = new(StringComparer.OrdinalIgnoreCase)
    { "Happy","Excited","Relaxed","Grateful","Confident" };

    private static readonly HashSet<string> Neutral = new(StringComparer.OrdinalIgnoreCase)
    { "Calm","Thoughtful","Curious","Nostalgic","Bored" };

    private static readonly HashSet<string> Negative = new(StringComparer.OrdinalIgnoreCase)
    { "Sad","Angry","Stressed","Lonely","Anxious" };

    // Computed outputs
    private int FilteredCount => _filtered.Count;

    private string FromAppliedLabel => FromApplied.ToString("MMM d, yyyy", CultureInfo.InvariantCulture);
    private string ToAppliedLabel => ToApplied.ToString("MMM d, yyyy", CultureInfo.InvariantCulture);

    private double PosPct, NeuPct, NegPct;
    private string MoodDistText = "";

    private string MoodPieStyle => BuildPieStyle(PosPct, NeuPct, NegPct);

    private int AvgWords = 0;

    private List<ChartRow> TopMoods = new();
    private List<ChartRow> TopTagsByUse = new();
    private List<TagBreakRow> TagBreakdown = new();

    private List<MonthPoint> MonthlySeries = new();
    private string TrendPoints = "";

    protected override async Task OnInitializedAsync()
    {
        _all = await Repo.GetAllAsync();
        ResetToLast30Days();
    }

    private void ResetToLast30Days()
    {
        var today = DateTime.Today;
        FromApplied = today.AddDays(-29);
        ToApplied = today;

        FromDraft = FromApplied.ToString("yyyy-MM-dd");
        ToDraft = ToApplied.ToString("yyyy-MM-dd");

        ApplyInternal();
    }

    private void OnFromChanged(ChangeEventArgs e) => FromDraft = e.Value?.ToString() ?? "";
    private void OnToChanged(ChangeEventArgs e) => ToDraft = e.Value?.ToString() ?? "";

    private void Apply()
    {
        var from = TryParseDate(FromDraft) ?? DateTime.Today.AddDays(-29);
        var to = TryParseDate(ToDraft) ?? DateTime.Today;

        if (to < from) (from, to) = (to, from);

        FromApplied = from.Date;
        ToApplied = to.Date;

        ApplyInternal();
    }

    private void ApplyInternal()
    {
        _filtered = _all
            .Where(e =>
            {
                var d = ParseEntryDate(e.EntryDate);
                return d >= FromApplied && d <= ToApplied;
            })
            .OrderBy(e => e.EntryDate)
            .ToList();

        ComputeAll();
        StateHasChanged();
    }

    private void ComputeAll()
    {
        ComputeMoodDistribution();
        ComputeFrequentMoods();
        ComputeTags();
        ComputeWordTrendsMonthly();
    }

    private void ComputeMoodDistribution()
    {
        int pos = 0, neu = 0, neg = 0;

        foreach (var e in _filtered)
        {
            var m = (e.PrimaryMood ?? "").Trim();
            if (Positive.Contains(m)) pos++;
            else if (Neutral.Contains(m)) neu++;
            else if (Negative.Contains(m)) neg++;
            else neu++;
        }

        var total = Math.Max(1, _filtered.Count);
        PosPct = pos * 100.0 / total;
        NeuPct = neu * 100.0 / total;
        NegPct = neg * 100.0 / total;

        MoodDistText = $"Positive {PosPct:0.#}% • Neutral {NeuPct:0.#}% • Negative {NegPct:0.#}%";
    }

    private void ComputeFrequentMoods()
    {
        var counts = _filtered
            .GroupBy(e => ((e.PrimaryMood ?? "Unknown").Trim()))
            .Select(g => new { Name = g.Key, Count = g.Count() })
            .OrderByDescending(x => x.Count)
            .ThenBy(x => x.Name)
            .Take(10)
            .ToList();

        var max = Math.Max(1, counts.FirstOrDefault()?.Count ?? 1);

        TopMoods = counts.Select(x => new ChartRow
        {
            Name = x.Name,
            Count = x.Count,
            WidthPct = x.Count * 100.0 / max,
            CloudSizePx = 12 + (x.Count * 18.0 / max) 
        }).ToList();
    }

    private void ComputeTags()
    {
        var tagUseCounts = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        var tagEntryCounts = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);

        foreach (var e in _filtered)
        {
            var tags = SplitTags(e.TagsCsv).ToList();
            if (tags.Count == 0) continue;

            foreach (var t in tags)
            {
                tagUseCounts[t] = tagUseCounts.TryGetValue(t, out var c) ? c + 1 : 1;
            }

            foreach (var t in tags.Distinct(StringComparer.OrdinalIgnoreCase))
            {
                tagEntryCounts[t] = tagEntryCounts.TryGetValue(t, out var c) ? c + 1 : 1;
            }
        }

        //most used tags (by occurrences)
        var topUse = tagUseCounts
            .OrderByDescending(kv => kv.Value)
            .ThenBy(kv => kv.Key)
            .Take(10)
            .ToList();

        var maxUse = Math.Max(1, topUse.FirstOrDefault().Value);

        TopTagsByUse = topUse.Select(x => new ChartRow
        {
            Name = x.Key,
            Count = x.Value,
            WidthPct = x.Value * 100.0 / maxUse,
            CloudSizePx = 0
        }).ToList();

        //breakdown (% of entries containing tag)
        var totalEntries = Math.Max(1, _filtered.Count);

        var topBreak = tagEntryCounts
            .OrderByDescending(kv => kv.Value)
            .ThenBy(kv => kv.Key)
            .Take(10)
            .ToList();

        TagBreakdown = topBreak.Select(x =>
        {
            var pct = x.Value * 100.0 / totalEntries;
            return new TagBreakRow
            {
                Name = x.Key,
                Count = x.Value,
                Percent = pct,
                WidthPct = pct
            };
        }).ToList();
    }

    private void ComputeWordTrendsMonthly()
    {
        //monthly avg words per entry
        var grouped = _filtered
            .Select(e =>
            {
                var d = ParseEntryDate(e.EntryDate);
                var words = GetWordCount(e);
                return new { Date = d, Words = words };
            })
            .GroupBy(x => new { x.Date.Year, x.Date.Month })
            .OrderBy(g => g.Key.Year).ThenBy(g => g.Key.Month)
            .Select(g =>
            {
                var label = new DateTime(g.Key.Year, g.Key.Month, 1)
                    .ToString("MMM yyyy", CultureInfo.InvariantCulture);

                var avg = g.Any() ? g.Average(x => x.Words) : 0;
                return new MonthPoint { Label = label, AvgWords = avg };
            })
            .ToList();

        MonthlySeries = grouped;

        AvgWords = (int)Math.Round(
            _filtered.Select(GetWordCount).DefaultIfEmpty(0).Average()
        );

        TrendPoints = BuildTrendPoints(MonthlySeries.Select(x => x.AvgWords).ToList());
    }

    private static string BuildTrendPoints(List<double> values)
    {
        //SVG frame
        const double left = 40;
        const double right = 680;
        const double top = 20;
        const double bottom = 190;

        if (values.Count == 0)
            return "";

        if (values.Count == 1)
        {
            // single point (flat)
            var y = bottom - 0.5 * (bottom - top);
            return $"{left},{y} {right},{y}";
        }

        var min = values.Min();
        var max = values.Max();
        var range = Math.Max(1e-6, max - min);

        var stepX = (right - left) / (values.Count - 1);

        var pts = new List<string>(values.Count);
        for (int i = 0; i < values.Count; i++)
        {
            var x = left + stepX * i;
            var norm = (values[i] - min) / range;
            var y = bottom - norm * (bottom - top);
            pts.Add($"{x.ToString("0.#", CultureInfo.InvariantCulture)},{y.ToString("0.#", CultureInfo.InvariantCulture)}");
        }

        return string.Join(" ", pts);
    }

    private static string BuildPieStyle(double pos, double neu, double neg)
    {
        var p1 = ClampPct(pos);
        var p2 = ClampPct(neu);
        var p3 = ClampPct(neg);

        var a = p1;
        var b = p1 + p2;
        var c = p1 + p2 + p3;

        return $"background: conic-gradient(var(--pos) 0% {a:0.###}%, var(--neu) {a:0.###}% {b:0.###}%, var(--neg) {b:0.###}% {c:0.###}%);";
    }

    private static double ClampPct(double v)
    {
        if (double.IsNaN(v) || double.IsInfinity(v)) return 0;
        return Math.Max(0, Math.Min(100, v));
    }

    private static int GetWordCount(JournalEntry e)
    {
        if (e.WordCount > 0) return e.WordCount;

        var text = (e.ContentText ?? "").Trim();
        if (string.IsNullOrWhiteSpace(text)) return 0;

        return text.Split((char[]?)null, StringSplitOptions.RemoveEmptyEntries).Length;
    }

    private static DateTime ParseEntryDate(string entryDate) =>
        DateTime.ParseExact(entryDate, "yyyy-MM-dd", CultureInfo.InvariantCulture).Date;

    private static DateTime? TryParseDate(string s)
    {
        if (string.IsNullOrWhiteSpace(s)) return null;
        if (DateTime.TryParseExact(s, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out var dt))
            return dt.Date;
        return null;
    }

    private static IEnumerable<string> SplitTags(string? csv)
    {
        if (string.IsNullOrWhiteSpace(csv)) return Enumerable.Empty<string>();
        return csv.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
    }

    private sealed class ChartRow
    {
        public string Name { get; set; } = "";
        public int Count { get; set; }
        public double WidthPct { get; set; }
        public double CloudSizePx { get; set; }
    }

    private sealed class TagBreakRow
    {
        public string Name { get; set; } = "";
        public int Count { get; set; }
        public double Percent { get; set; }
        public double WidthPct { get; set; }
    }

    private sealed class MonthPoint
    {
        public string Label { get; set; } = "";
        public double AvgWords { get; set; }
    }
}
